/**
 * JGraphMath
 * Copyright (C) 2015 Jeremiah N. Hankins
 *
 * This program is free software: you can redistribute it and/or modify it under
 * the terms of the GNU General Public License as published by the Free Software
 * Foundation, either version 3 of the License, or (at your option) any later
 * version.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
 * details.
 *
 * You should have received a copy of the GNU General Public License along with
 * this program. If not, see <http://www.gnu.org/licenses/>.
 */

package com.jnhankins.graph;

import java.math.BigInteger;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Comparator;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.NoSuchElementException;
import java.util.Random;
import java.util.TreeMap;

/**
 * {@code Graph} represents a simple, unweighted labeled
 * <a href="https://en.wikipedia.org/wiki/Graph_(mathematics)">graph</a>.
 * <p>
 * At its core {@code Graph} stores the graph it represents using an boolean
 * <a href="https://en.wikipedia.org/wiki/Adjacency_matrix">adjacency matrix
 * </a>. However since an undirected graph's adjacency matrix is a
 * <a href="https://en.wikipedia.org/wiki/Symmetric_matrix">symmetric matrix
 * </a>, only the lower
 * <a href="https://en.wikipedia.org/wiki/Triangular_matrix">triangular matrix
 * </a> is stored.
 * <pre>
 * Example usage:
 * {@code // The following code fills a list with every connected labeled graph that 
 * // has more than one vertex and fewer than 8 verticies.
 * 
 * List<Graph> list = new ArrayList();
 * for (int v = 2; v < 8; v++) {
 *    Graph g = Graph.makeGraph(v);
 *    do {
 *       if (g.isConnected())
 *          list.add(Graph.copyGraph(h));
 *    } while (g.increment());
 * }}</pre>
 * 
 * @see BaseGraph
 * @see Subgraph
 * @author Jeremiah N. Hankins
 */
public abstract class Graph implements Iterable<Boolean> {
    
    /***************************************************************************
     * Final Member Variables
     **************************************************************************/
    
    /**
     * The number of vertices.
     */
    protected final int order;
    
    /**
     * The maximum number of edges a graph of this graph's could contain. In
     * other words, the maximum edge index plus one.
     */
    protected final long maxSize;
    
    /***************************************************************************
     * Lazy Member Variables
     **************************************************************************/
    
    /** 
    * The number of edges in this graph.
     * <p>
     * Uses lazy instantiation.
     * @see #getSize()
     */
    protected Long size = null;
    
    /**
     * An array containing the degree sequence.
     * <p>
     * Uses lazy instantiation.
     * @see #getDegreeSequence()
     */
    protected int[] degrees = null;
    
    /**
     * The adjacency list representation of the graph.
     * <p>
     * Uses lazy instantiation.
     * @see #getAdjacencyList()
     */
    protected int[][] adjacency = null;
    
    /**
     * A jagged array representation of the disjoint components of this graph
     * whose union form the graph.
     * <p>
     * Uses lazy instantiation.
     * @see #getComponents()
     */
    protected int[][] components = null;
    
    /**
     * An array of subgraphs representing of the disjoint components of this 
     * graph whose union form the graph. 
     * <p>
     * Uses lazy instantiation.
     * @see #getComponentSubgraphs()
     */
    protected Subgraph[] componentGraphs = null;
    
    /**
     * An array containing BFS-SLR trees, such that each BFS-SLR tree in the
     * array is rooted at a different node in this graph.
     * <p>
     * <b>Experimental</b>
     */
    protected Tree[] bfsslrTrees = null;
    
    /**
     * An array containing the the canonical tree number of each BFS-SLR tree,
     * such that the canonical numbers are bit-packed into a {@code long} array.
     * <p>
     * <b>Experimental</b>
     */
    protected long[][] bfsslrTreeNumbers = null;
    
    /**
     * A number bit-packed into a {@code long} array which represents much of
     * the topology of the graph. Generated by sorting and concatenating the
     * canonical numbers of the BFS-SLR trees.
     * <p>
     * <b>Experimental</b>
     */
    protected long[] bfsslrTreeNumber = null;
    
    /**
     * A potential semi-canonical mapping which can accelerate isomorphism tests
     * in some circumstances.
     * <p>
     * <b>Experimental</b>
     */
    protected int[] bfsslrMap = null;
    
    /***************************************************************************
     * Constructor
     **************************************************************************/
    
    /**
     * Initializes the {@code Graph} using the specified number of vertices.
     * 
     * @param order the number of vertices
     */
    protected Graph(int order) {
        this.order = order;
        maxSize = getMaximumSize(order);
    }
    
    
    
    /***************************************************************************
     * Abstract
     **************************************************************************/
    
    /**
     * Implementation of {@link #getEdge(long)} for internal use only.
     * Implementations of this method do not need to check the range of
     * {@code edgeIndex}.
     * 
     * @param edgeIndex the index of the edge being tested
     * @return {@code true} if this graph has an edge at the specified index
     */
    protected abstract boolean getEdgeInternal(long edgeIndex);
    
    /**
     * Implementation of {@link #setEdge(long, boolean)} for internal use only.
     * Implementations of this method do not need to check the range of
     * {@code edgeIndex}, and should not invoke {@link #modified()}.
     * 
     * @param edgeIndex the index of the edge being set
     * @param value if {@code true} the graph will contain the edge after the
     * method call, otherwise it will not
     */
    protected abstract void setEdgeInternal(long edgeIndex, boolean value);
    
    
    
    /***************************************************************************
     * Basic Getters and Setters
     **************************************************************************/
    
    /**
     * Returns the number of vertices in the graph.
     * 
     * @return the number of vertices in the graph
     */
    public int getOrder() {
        return order;
    }
    
    /**
     * Returns the maximum number of edges a graph of this graph's
     * {@link #getOrder() order} could contain. In other words, returns the maximum
     * edge index plus one.
     * 
     * @return the maximum number of edges a graph of this graph's order could
     * contain
     */
    public long getMaximumSize() {
        return maxSize;
    }
    
    /**
     * Returns {@code true} if the graph has an edge at the specified index.
     * <p>
     * Edge indices are taken from the lower triangle of the graph's adjacency
     * matrix ordered from left to right and top to bottom. For example, the
     * indexes of the edges in the adjacency matrix of a graph with five
     * vertices are:
     * <pre>
     *   - 0 1 3 6
     *   0 - 2 4 7
     *   1 2 - 5 8
     *   3 4 5 - 9
     *   6 7 8 9 -</pre>
     *
     * @param edgeIndex the index of the edge being tested
     * @return {@code true} if this graph has an edge at the specified index
     * @throws IndexOutOfBoundsException if {@code edgeIndex} is not in the 
     * range {@code [0, getMaximumSize())}
     */
    public boolean getEdge(long edgeIndex) {
        if (edgeIndex < 0 || edgeIndex >= maxSize)
            throw new IndexOutOfBoundsException("edgeIndex is not in range: edgeIndex="+edgeIndex+", range [0, "+maxSize+")");
        return getEdgeInternal(edgeIndex);
    }
    
    /**
     * Returns {@code true} if the graph has an edge between the two vertices
     * with the specified indices.
     *
     * @param vertIndexA the index of the first vertex
     * @param vertIndexB the index of the second vertex
     * @return {@code true} if there is an edge connecting the vertices
     * @throws IndexOutOfBoundsException if {@code vertIndexA} or
     * {@code vertIndexB} is not in the range {@code [0, order())}
     */
    public boolean getEdge(int vertIndexA, int vertIndexB) {
        if (vertIndexA < 0 || vertIndexA >= order)
            throw new IndexOutOfBoundsException("vertIndexA is not in range: vertIndexA="+vertIndexA+", range [0, "+order+")");
        if (vertIndexB < 0 && vertIndexB >= order)
            throw new IndexOutOfBoundsException("vertIndexB is not in range: vertIndexB="+vertIndexB+", range [0, "+order+")");
        
        if (vertIndexA > vertIndexB) // lower triangle
            return getEdge(vertIndexA*(vertIndexA-1)/2+vertIndexB);
        if (vertIndexA < vertIndexB) // upper triangle
            return getEdge(vertIndexB*(vertIndexB-1)/2+vertIndexA);
        return false;
    }
    
    /**
     * Sets the the presence or absence of the edge at the specified index in
     * the graph. If {@code value} is {@code true}, then the graph will contain
     * the specified edge after this method call, otherwise it will not.
     * <p>
     * Edge indexes are taken from the lower triangle of the graph's adjacency
     * matrix ordered from left to right and top to bottom. For example, the
     * indexes of the edges in the adjacency matrix of a graph with five
     * vertices are:
     * <pre>
     *   - 0 1 3 6
     *   0 - 2 4 7
     *   1 2 - 5 8
     *   3 4 5 - 9
     *   6 7 8 9 -</pre>
     * 
     * @param edgeIndex the index of the edge being set
     * @param value if {@code true} the graph will contain the edge after the
     * method call, otherwise it will not
     * @throws IndexOutOfBoundsException if {@code edgeIndex} is not in the 
     * range {@code [0, getMaximumSize())}
     */
    public void setEdge(long edgeIndex, boolean value) {
        if (edgeIndex < 0 || edgeIndex >= maxSize)
            throw new IndexOutOfBoundsException("edgeIndex is not in range: edgeIndex="+edgeIndex+", range [0, "+maxSize+")");
            
        setEdgeInternal(edgeIndex, value);
        modified();
    }
    
    /**
     * Sets the the presence or absence of the edge an edge between the two
     * vertices with the specified indices. If {@code value} is {@code true},
     * then the graph will contain the specified edge after this method call,
     * otherwise it will not. If {@code (vertIndexA == vertIndexB)} then this
     * method will have no effect.
     * 
     * @param vertIndexA the index of the first vertex
     * @param vertIndexB the index of the second vertex
     * @param value if {@code true} the graph will contain the edge after the
     * method call, otherwise it will not
     * @throws IndexOutOfBoundsException if {@code vertIndexA} or
     * {@code vertIndexB} is not in the range {@code [0, order())}
     */
    public void setEdge(int vertIndexA, int vertIndexB, boolean value) {
        if (vertIndexA < 0 || vertIndexA >= order)
            throw new IndexOutOfBoundsException("vertIndexA is not in range: vertIndexA="+vertIndexA+", range [0, "+order+")");
        if (vertIndexB < 0 && vertIndexB >= order)
            throw new IndexOutOfBoundsException("vertIndexB is not in range: vertIndexB="+vertIndexB+", range [0, "+order+")");
        
        if (vertIndexA > vertIndexB) // lower triangle
            setEdge(vertIndexA*(vertIndexA-1)/2+vertIndexB, value);
        if (vertIndexA < vertIndexB) // upper triangle
            setEdge(vertIndexB*(vertIndexB-1)/2+vertIndexA, value);
    }
    
    /**
     * Implementation of {@link #setEdge(int, int, boolean)} for internal use
     * only. This method does not check the range of {@code vertIndexA} or
     * {@code vertIndexB}, and will not invoke {@link #modified()}.
     * 
     * @param vertIndexA the index of the first vertex
     * @param vertIndexB the index of the second vertex
     * @param value if {@code true} the graph will contain the edge after the
     * method call, otherwise it will not
     * @see #setEdgeInternal(long, boolean) 
     */
    protected void setEdgeInternal(int vertIndexA, int vertIndexB, boolean value) {
        if (vertIndexA > vertIndexB) // lower triangle
            setEdgeInternal(vertIndexA*(vertIndexA-1)/2+vertIndexB, value);
        if (vertIndexA < vertIndexB) // upper triangle
            setEdgeInternal(vertIndexB*(vertIndexB-1)/2+vertIndexA, value);
    }
    
    
    
    /***************************************************************************
     * Modifiers
     **************************************************************************/
    
    /**
     * Signals that the graphs adjacency matrix has been modified.
     * <p>
     * If this method is overridden, the overriding method should invoke
     * {@code super.modified()} so that the subgraphs are still notified about
     * the modification.
     */
    void modified() {
        // Clear cached data
        size = null;
        degrees = null;
        adjacency = null;
        components = null;
        componentGraphs = null; 
        
        // Experimental
        bfsslrTrees = null;
        bfsslrTreeNumbers = null;
        bfsslrTreeNumber = null;
        bfsslrMap = null;
    }
    
    /**
     * Randomizes the edges contained in the graph. This method randomizes the
     * entries in the graph's adjacency matrix.
     */
    public void randomize() {
        Random random = new Random();
        for (long i=0; i<maxSize; i++)
            setEdgeInternal(i, random.nextBoolean());
        modified();
    }
    
    /**
     * Modifies this graph so that it represents its complement after the call.
     * If two vertices share an edge before the call, they will not share an
     * edge after the call. If two vertices did not share an edge before the
     * call, they will share an edge after the call.
     */
    public void complement() {
        for (long i=0; i<maxSize; i++)
            setEdgeInternal(i, !getEdge(i));
        modified();
    }
    
    /**
     * Modifies this graph in such a way that the value returned by 
     * {@link #toBigInt()} will be incremented by one after the call.
     * By repeatedly invoking this method it is possible to generate every graph
     * (i.e. every possible edge configuration) for a graph of this
     * {@link #getOrder() order}. Returns {@code false} if the graph 
     * "rolls over" and transitions from a complete graph to an empty graph,
     * otherwise {@code true}.
     * 
     * @return {@code false} if the graph transitions from a complete graph to
     * an empty graph, otherwise {@code true}
     */
    public boolean increment() {
        for (long i=0; i<maxSize; i++) {
            if(getEdge(i)) {
                setEdgeInternal(i, false);
            } else {
                setEdgeInternal(i, true);
                modified();
                return true;
            }
        }
        modified();
        return false;
    }
    
    /**
     * Modifies this graph in such a way that the value returned by
     * {@link #toBigInt()} will be incremented by the specified after the call.
     * Returns {@code false} if the graph "rolls over" and transitions from a
     * complete graph to an empty graph during the operation, otherwise
     * {@code true}.
     * 
     * @return {@code false} if the graph transitions from a complete graph to
     * an empty graph during the operation, otherwise {@code true}
     */
    public boolean increment(int x) {
        boolean b = false;
        for (int j=0; j<x; j++) {
            for (long i=0; i<maxSize; i++) {
                if(getEdge(i)) {
                    setEdgeInternal(i, false);
                } else {
                    setEdgeInternal(i, true);
                    b = true;
                    break;
                }
            }
        }
        modified();
        return b;
    }
    
    /***************************************************************************
     * Iterators
     **************************************************************************/
    
    /**
     * An enumeration representing the order in which elements of the lower
     * triangle of a graph's adjacency matrix are traversed.
     * 
     * @see Traverser
     * @author Jeremiah N. Hankins
     */
    public static enum TraversalOrder {
        /**
         * Left-to-right (top-to-bottom).
         * <pre>{@code
         * 0
         * 1 2
         * 3 4 5}</pre>
         */
        LRTB(true, true, true),

        /**
         * Left-to-right (bottom-to-top).
         * <pre>{@code
         * 5
         * 3 4
         * 0 1 2}</pre>
         */
        LRBT(true, true, false),

        /**
         * Right-to-left (top-to-bottom).
         * <pre>{@code
         * 0
         * 2 1
         * 5 4 3}</pre>
         */
        RLTB(true, false, true),

        /**
         * Right-to-left (bottom-to-top).
         * <pre>{@code
         * 5
         * 4 3
         * 2 1 0}</pre>
         */
        RLBT(true, false, false),

        /**
         * Top-to-bottom (left-to-right).
         * <pre>{@code
         * 0
         * 1 3
         * 2 4 5}</pre>
         */
        TBLR(false, true, true),

        /**
         * Bottom-to-top (left-to-right).
         * <pre>{@code
         * 2
         * 1 4
         * 0 3 5}</pre>
         */
        BTLR(false, true, false),

        /**
         * Top-to-bottom (right-to-left).
         * <pre>{@code
         * 3
         * 4 1
         * 5 2 0}</pre>
         */
        TBRL(false, false, true),

        /**
         * Bottom-to-top (right-to-left).
         * <pre>{@code
         * 5
         * 4 2
         * 3 1 0}</pre>
         */
        BTRL(false, false, false);

        boolean major;
        boolean coldir;
        boolean rowdir;

        TraversalOrder(boolean major, boolean coldir, boolean rowdir) {
            this.coldir = coldir;
            this.rowdir = rowdir;
            this.major = major;
        }

        /**
         * Returns {@code true} if row-major order and {@code false} if
         * column-major order.
         * 
         * @return {@code true} if row-major order
         */
        public boolean getMajorOrder() {
            return major;
        }

        /**
         * Returns {@code true} if rows are read from left to right and
         * {@code false} if rows are read from right to left.
         * 
         * @return {@code true} if rows are read from left to right
         */
        public boolean getRowDirection() {
            return coldir;
        }

        /**
         * Returns {@code true} if columns are read from top to bottom and
         * {@code false} if columns are read from bottom to top.
         * 
         * @return {@code true} if columns are read from top to bottom
         */
        public boolean getColDirection() {
            return coldir;
        }

        /**
         * Returns a {@code TraversalOrder} whose traversal order is exactly
         * opposite of the traversal order of this {@code TraversalOrder}.
         *
         * @return the reverse of this {@code TraversalOrder}
         */
        public TraversalOrder reverse() {
            return get(major, !coldir, !rowdir);
        }

        /**
         * Returns a {@code TraversalOrder} with the specified properties.
         * 
         * @param major if (@code true}, every column in a row will be read
         * before moving to the next column (row major order); if {@code false},
         * every row in a column will be read before moving to the next row
         * (column major order)
         * @param coldir if {@code true} columns will be read from from
         * left to right, otherwise they will be read from right to left
         * @param rowdir if {@code true} rows will be read from top to bottom,
         * otherwise they will be read from bottom to top
         * @return a {@code TraversalOrder} with the specified properties
         */
        public static TraversalOrder get(boolean major, boolean coldir, boolean rowdir) {
            if (major)
                if (coldir)
                    if (rowdir)
                        return LRTB;
                    else
                        return LRBT;
                else
                    if (rowdir)
                        return RLTB;
                    else
                        return RLBT;
            else
                if (coldir)
                    if (rowdir)
                        return TBLR;
                    else
                        return BTLR;
                else
                    if (rowdir)
                        return TBRL;
                    else
                        return BTRL;
        }
    }
    
    /**
     * An iterator which traverses the bits in the lower triangle of a graph's
     * adjacency matrix that allows the traversal order to be specified during 
     * construction and allows the contents of the matrix to be modified during 
     * iteration.
     * 
     * @see TraversalOrder
     * @author Jeremiah N. Hankins
     */
    public static class Traverser implements Iterator<Boolean> {
        final Graph graph;
        final TraversalOrder traversalOrder;
        final int rowDir;
        final int colDir;
        int nextRow;
        int nextCol;
        long nextIdx;
        long prevIdx;
        
        /**
         * Constructs a new {@code Traverser} on the specified graph which will
         * iterate over the bits in the lower triangle of the graph's adjacency
         * matrix from left left-to-right then top-to-bottom.
         * 
         * @param graph the graph to traverse
         * @throws NullPointerException if {@code graph} is {@code null}
         */
        public Traverser(Graph graph) {
            this(graph, TraversalOrder.LRTB);
        }
        
        /**
         * Constructs a new {@code Traverser} on the specified graph which will
         * iterate over the bits in the lower triangle of the graph's adjacency
         * matrix using the specified traversal order.
         * 
         * @param graph the graph to traverse
         * @param traversalOrder the order that bits will be traversed in the
         * adjacency matrix
         * @throws NullPointerException if {@code graph} or
         * {@code traversalOrder} is {@code null}
         */
        public Traverser(Graph graph, TraversalOrder traversalOrder) {
            this.graph = graph;
            this.traversalOrder = traversalOrder;

            colDir = traversalOrder.rowdir ? 1 : -1;
            rowDir = traversalOrder.coldir ? 1 : -1;

            if (traversalOrder.major) {
                nextRow = traversalOrder.coldir ? 1 : graph.order - 1;
                nextCol = traversalOrder.rowdir ? 0 : nextRow - 1;
            } else {
                nextCol = traversalOrder.rowdir ? 0 : graph.order - 2;
                nextRow = traversalOrder.coldir ? nextCol + 1 : graph.order - 1;
            }
            nextIdx = nextRow * (nextRow - 1L) / 2L + nextCol;
            prevIdx = -1;
        }

        /**
         * Returns the row index of the element that would be returned by a
         * subsequent call to {@link #next()}.
         *
         * @return the row index of the element that would be returned by a
         * subsequent call to {@code next}
         */
        public int nextRow() {
            return nextRow;
        }

        /**
         * Returns the column index of the element that would be returned by a
         * subsequent call to {@link #next()}.
         *
         * @return the column index of the element that would be returned by a
         * subsequent call to {@code next}
         */
        public int nextCol() {
            return nextCol;
        }

        /**
         * Returns the index of the element that would be returned by a
         * subsequent call to {@link #next()}.
         *
         * @return the index of the element that would be returned by a
         * subsequent call to {@code next}
         */
        public long nextIndex() {
            return nextIdx;
        }

        /**
         * Returns {@code true} if the iteration has more elements. (In other
         * words, returns {@code true} if {@code next()} would return an element
         * rather than throwing an exception.)
         *
         * @return true if the iteration has more elements
         */
        @Override
        public boolean hasNext() {
            return 0 <= nextIdx && nextIdx < graph.maxSize;
        }

        /**
         * Skips the next element without reading it and advances the
         * traverser's position.
         *
         * @throws NoSuchElementException if the traverser has no next element
         */
        public void skip() {
            // If there are no more bits to read, throw an exception
            if (!hasNext())
                throw new NoSuchElementException();

            // Advance the row, column, and index
            advance();
        }

        /**
         * Returns the next element from the graph's adjacency matrix and
         * advances the traverser's position.
         *
         * @return the next element from the graph's adjacency matrix
         * @throws NoSuchElementException if the traverser has no next element
         */
        @Override
        public Boolean next() {
            // If there are no more bits to read, throw an exception
            if (!hasNext()) 
                throw new NoSuchElementException();

            // Advance the row, column, and index
            advance();

            // Return the bit that was read
            return graph.getEdge(prevIdx);
        }

        /**
         * Replaces the last element returned by {@link #next()} or skipped by
         * {@link #skip()} with the specified value.
         *
         * @param value the element with which to replace the last element
         * returned by {@code next} or skipped by {@code skip}
         * @throws IllegalStateException if {@code next} has not been called
         */
        public void set(boolean value) {
            if (prevIdx == -1) 
                throw new IllegalStateException();

            graph.setEdge(prevIdx, value);
        }

        void advance() {
            // Store the previous index (for use by the set method)
            prevIdx = nextIdx;

            // Calcuclate the next row and column, based on the traveral order
            if (traversalOrder.major) {
                if (traversalOrder.rowdir) {
                    if (++nextCol >= nextRow) {
                        nextRow += rowDir;
                        nextCol = 0;
                    }
                } else {
                    if (--nextCol < 0) {
                        nextRow += rowDir;
                        nextCol = nextRow - 1;
                    }
                }
            } else {
                if (traversalOrder.coldir) {
                    if (++nextRow >= graph.order) {
                        nextCol += colDir;
                        nextRow = nextCol + 1;
                    }
                } else {
                    if (--nextRow >= nextCol) {
                        nextCol += colDir;
                        nextRow = graph.order - 1;
                    }
                }
            }

            // Calculate the next edge index based on the new row and column
            nextIdx = nextRow * (nextRow - 1L) / 2L + nextCol;
        }
    }
    
    /**
     * Returns an iterator that traverses the lower triangle of the graph's
     * adjacency matrix from left left-to-right then top-to-bottom.
     * <p>
     * Equivalent to {@code traverser(TraversalOrder.LRTB)}.
     *
     * @return an iterator that traverses the lower triangle of the graph's
     * adjacency matrix
     * @see #traverser(TraversalOrder) 
     */
    public Traverser traverser() {
        return new Traverser(this);
    }
    
    /**
     * Returns an iterator that traverses the lower triangle of the graph's
     * adjacency matrix in the specified order.
     * 
     * @param traversalOrder the order that the lower triangle of the graph's
     * adjacency matrix is traversed
     * @return an iterator that traverses the lower triangle of the graph's
     * adjacency matrix
     * @throws NullPointerException if {@code traversalOrder} is {@code null}
     */
    public Traverser traverser(TraversalOrder traversalOrder) {
        return new Traverser(this, traversalOrder);
    }
    
    /**
     * Returns an iterator that traverses the lower triangle of the graph's
     * adjacency matrix by reading bits from left left-to-right then 
     * top-to-bottom.
     * <p>
     * Equivalent to {@code iterator(TraversalOrder.LRTB)}.
     *
     * @return an iterator that traverses the lower triangle of the graph's
     * adjacency matrix
     * @see #iterator(TraversalOrder) 
     */
    @Override
    public Iterator<Boolean> iterator() {
        return traverser();
    }
    
    /**
     * Returns an iterator that traverses the lower triangle of the graph's
     * adjacency matrix in the specified order.
     * top-to-bottom.
     * <p>
     * Equivalent to {@code traverser(traversalOrder)}.
     * 
     * @param traversalOrder the order that the lower triangle of the graph's
     * adjacency matrix is traversed
     * @return an iterator that traverses the lower triangle of the graph's
     * adjacency matrix
     * @throws NullPointerException if {@code traversalOrder} is {@code null}
     * @see #traverser(TraversalOrder) 
     */
    public Iterator<Boolean> iterator(TraversalOrder traversalOrder) {
        return traverser(traversalOrder);
    }
    
    /**
     * Returns an iterator that returns vertex indices in the order they are
     * visited using a breadth-first search rooted at the specified index.
     * 
     * The behavior of the returned iterator is undefined if the graph is
     * modified before the iteration has finished (i.e. the iterator is not
     * fast-fail and does not check for concurrent modifications).
     * 
     * @param rootIndex the index of the vertex from which the
     * breadth-first search will begin
     * @return a breadth-first search vertex iterator
     * @throws IllegalArgumentException if {@code rootIndex} is not in range 
     * [0, {@code order})
     */
    public Iterator<Integer> bfsIterator(int rootIndex) {
        if (rootIndex < 0 || order <= rootIndex)
            throw new IllegalArgumentException("rootIndex is not in range [0,order): rootIndex="+rootIndex+", order="+order);
            
        class BfsIterator implements Iterator<Integer> {
            boolean[] marked = new boolean[order];
            int[] queue = new int[order];  
            int qfront = 0;
            int qback = 0;

            BfsIterator(int rootIndex) {
                marked[rootIndex] = true;
                queue[qback++] = rootIndex;
            }

            @Override
            public boolean hasNext() {
                return qfront < qback;
            }

            @Override
            public Integer next() {
                if (!hasNext())
                    throw new NoSuchElementException();
                
                // Dequeue the next verted
                int next = queue[qfront++];

                // Enqueue all unmarked children and mark them
                int[] adj = getAdjacencyList()[next];
                for (int i=0; i<adj.length; i++) {
                    int a = adj[i];
                    if (!marked[a]) {
                        marked[a] = true;
                        queue[qback++] = a;
                    }
                }
                
                // Return the vertex
                return next;
            }
        }
        
        return new BfsIterator(rootIndex);
    }
    
    /**
     * Returns an iterator that returns vertex indices in the order they are
     * visited using a depth-first search rooted at the specified index.
     *
     * The behavior of the returned iterator is undefined if the graph is
     * modified before the iteration has finished (i.e. the iterator is not
     * fast-fail and does not check for concurrent modifications).
     *
     * @param rootIndex the index of the vertex from which the
     * depth-first search will begin
     * @return a depth-first search vertex iterator
     * @throws IllegalArgumentException if {@code rootIndex} is not in range 
     * [0, {@code order})
     */
    public Iterator<Integer> dfsIterator(int rootIndex) {
        if (rootIndex < 0 || order <= rootIndex)
            throw new IllegalArgumentException("rootIndex is not in range [0,order): rootIndex="+rootIndex+", order="+order);
            
        class DfsIterator implements Iterator<Integer> {
            boolean[] marked = new boolean[order];
            int[] stack = new int[order*order];  
            int stackIndex = 0;

            DfsIterator(int rootIndex) {
                marked[rootIndex] = true;
                stack[stackIndex] = rootIndex;
            }

            @Override
            public boolean hasNext() {
                return stackIndex >= 0;
            }

            @Override
            public Integer next() {
                if (!hasNext())
                    throw new NoSuchElementException();
                
                // Pop the next vertex and mark it
                int next = stack[stackIndex--];
                marked[next] = true;
                
                // Push unmakred children
                int[] adj = getAdjacencyList()[next];
                for (int i=0; i<adj.length; i++) {
                    stack[++stackIndex] = adj[i];
                }
                
                // Pop untill an unmarked vertex is found or the stack is empty
                while (stackIndex >= 0 && marked[stack[stackIndex]])
                    stackIndex--;
                
                // Return the vertex
                return next;
            }
        }
        
        return new DfsIterator(rootIndex);
    }
    
    
    
    /***************************************************************************
     * Format Converters
     **************************************************************************/
    
    /**
     * Returns a string representation of the lower triangle of the graph's
     * adjacency matrix interpreted as a decimal integer.
     * <p>
     * Equivalent to {@code toString(TraversalOrder.LRTB, 10)}.
     *
     * @return a binary string representation of the graph
     * @see #toString(TraversalOrder, int) 
     */
    @Override
    public String toString() {
        return toString(TraversalOrder.LRTB, 10);
    }
    
    /**
     * Returns a string representation of the graph by interpreting the lower
     * triangle of the graph's adjacency matrix as an integer with the specified
     * radix using the specified traversal order. If the specified radix cannot
     * be accommodated, it will default to 10.
     * <p>
     * Equivalent to {@code toBigInt(traversalOrder).toString(radix)}.
     * 
     * @param traversalOrder the order bits are be read from the adjacency
     * matrix
     * @param radix the radix to use
     * @return a binary string representation of the graph
     * @throws NullPointerException if {@code traversalOrder} is {@code null}
     * @see #toBigInt()
     * @see BigInteger#toString(int)
     */
    public String toString(TraversalOrder traversalOrder, int radix) {
        return toBigInt(traversalOrder).toString(radix);
    }
    
    /**
     * Returns a {@code BigInteger} representation of the graph by interpreting
     * the lower triangle of the graph's adjacency matrix as an integer.
     * <p>
     * Equivalent to {@code toBigInt(TraversalOrder.LRTB)}.
     *
     * @return a {@code BigInteger} representation of the graph
     */
    public BigInteger toBigInt() {
        return toBigInt(TraversalOrder.LRTB);
    }
    
    /**
     * Returns a {@code BigInteger} representation of the of the graph by
     * interpreting the lower triangle of the graph's adjacency matrix as an
     * integer using specified the traversal order. The first bit read will be
     * the least significant digit.
     * 
     * @param traversalOrder the order bits are be read from the adjacency
     * matrix
     * @return a {@code BigInteger} representation of the graph
     * @throws NullPointerException if {@code traversalOrder} is {@code null}
     */
    public BigInteger toBigInt(TraversalOrder traversalOrder) {
        BigInteger bi = BigInteger.ZERO;
        Iterator<Boolean> it = iterator(traversalOrder.reverse());
        while (it.hasNext()) {
            bi = bi.shiftLeft(1);
            if (it.next()) {
                bi = bi.setBit(0);
            }
        }
        return bi;
    }
    
    /**
     * Sets the contents of the lower triangle of the graph's adjacency matrix
     * by interpreting the specified string as a decimal integer and copying
     * bits from the integer's binary representation.
     * <p>
     * Equivalent to {@code fromString(str, 10, TraversalOrder.LRTB)}.
     * 
     * @param str string representation of a decimal integer
     * @throws NullPointerException if {@code str} is {@code null}
     * @throws NumberFormatException {@code str} is not a valid representation
     * of a decimal integer
     */
    public void fromString(String str) {
        fromString(str, 10, TraversalOrder.LRTB);
    }
    
    /**
     * Sets the contents of the lower triangle of the graph's adjacency matrix
     * by interpreting the specified string as an integer with the specified
     * radix and copying bits from the integer's binary representation into the
     * adjacency matrix using the traversal order specified such that the first
     * bit traversed in the matrix is equivalent to the least significant bit in
     * the integer.
     * If the integer contains more bits than the lower triangle of the
     * adjacency matrix, it will be truncated. If the integer contains few bits
     * than the lower triangle of the adjacency matrix, the remaining bits will
     * be zeroed (set to {@code false}).
     * <p>
     * Equivalent to
     * {@code fromBigInt(new BigInteger(str, radix), traversalOrder)}.
     * 
     * @param str string representation of a integer
     * @param radix the radix to be used in interpreting {@code str}
     * @throws NullPointerException if {@code str} or {@code traversalOrder} are
     * {@code null}
     * @param traversalOrder the order bits are be read from the adjacency
     * matrix
     * @throws NullPointerException if either {@code str} or
     * {@code traversalOrder} are {@code null}
     * @throws NumberFormatException {@code str} is not a valid representation
     * of an integer in the specified radix, or radix is outside the range
     * [{@code Character.MIN_RADIX}, {@code Character.MAX_RADIX}]
     * @see BigInteger#BigInteger(java.lang.String, int) 
     * @see #fromBigInt(BigInteger, TraversalOrder) 
     */
    public void fromString(String str, int radix, TraversalOrder traversalOrder) {
        fromBigInt(new BigInteger(str, radix), traversalOrder);
    }
    
    /**
     * Sets the contents of the lower triangle of the graph's adjacency matrix
     * by copying bits from the specified integer. 
     * 
     * If the integer contains more bits than the lower triangle of the
     * adjacency matrix, it will be truncated. If the integer contains few bits
     * than the lower triangle of the adjacency matrix, the remaining bits will
     * be zeroed (set to {@code false}).
     * <p>
     * Equivalent to fromBigInt(integer, TraversalOrder.LRTB)}.
     * 
     * @param bigint the integer whose bits will be copied
     * @throws NullPointerException if {@code integer} is {@code null}
     * @see #fromBigInt(BigInteger, TraversalOrder) 
     */
    public void fromBigInt(BigInteger bigint) {
        fromBigInt(bigint, TraversalOrder.LRTB);
    }
    
    /**
     * Sets the contents of the lower triangle of the graph's adjacency matrix
     * by traversing the matrix in the order specified and copying bits from the
     * binary representation of the specified integer such that the first bit
     * traversed in the matrix is equivalent to the least significant bit in the
     * specified integer. 
     * 
     * If the integer contains more bits than the lower triangle of the
     * adjacency matrix, it will be truncated. If the integer contains few bits
     * than the lower triangle of the adjacency matrix, the remaining bits will
     * be zeroed (set to {@code false}).
     * 
     * @param bigint the integer whose bits will be copied
     * @param traversalOrder the order in which bits will be set in the
     * adjacency matrix
     * @throws NullPointerException if either {@code integer} or
     * {@code traversalOrder} are {@code null}
     */
    public void fromBigInt(BigInteger bigint, TraversalOrder traversalOrder) {
        Traverser t = traverser(traversalOrder);
        while (t.hasNext()) {
            long idx = t.nextIndex();
            setEdgeInternal(idx, bigint.testBit(0));
            bigint = bigint.shiftRight(1);
            t.skip();
        }
        modified();
    }
    
    
    
    /***************************************************************************
     * Printers
     **************************************************************************/
    
    /**
     * Prints the graph's adjacency matrix to the standard output stream.
     */
    public void printMatrix() {
        StringBuilder str = new StringBuilder();
        for (int row = 0; row < order; row++) {
            for (int col = 0; col < order; col++)
                str.append(getEdge(row, col)?"1 ":"0 ");
            str.append("\n");
        }
        System.out.print(str);
    }
    
    /**
     * Prints the upper triangle of the graph's adjacency matrix to the standard
     * output stream.
     */
    public void printUpperTriangle() {
        StringBuilder str = new StringBuilder();
        for (int r=0; r<order-1; r++) {
            int c = 0;
            for (; c<=r; c++)
                str.append("  ");
            for (; c<order; c++)
                str.append(getEdge(r, c) ? "1 ": "0 ");
            str.append("\n");
        }
        System.out.print(str);
    }
    
    /**
     * Prints the lower triangle of the graph's adjacency matrix to the standard
     * output stream.
     */
    public void printLowerTriangle() {
        StringBuilder str = new StringBuilder();
        for (int r=1; r<order; r++) {
            for (int c=0; c<r; c++)
                str.append(getEdge(r, c) ? "1 " : "0 ");
            str.append("\n");
        }
        System.out.print(str);
    }
    
    
    
    /***************************************************************************
     * Lazy Getters
     **************************************************************************/
    
    /**
     * Returns the number of edges in this graph.
     * 
     * @return the number of edges
     */
    public long getSize() {
        if (size == null) {
            long total = 0;
            int o = order;
            int[][] e = getAdjacencyList();
            for (int i=0; i<o; i++)
                total += e[i].length;
            size = total/2;
        }
        return size;
    }
    
    /**
     * Returns an adjacency list representation of the graph.
     * <p>
     * The returned array is a jagged array of integers. The length of the array
     * is equal to the number of vertices, such that each vertex has its own
     * sub-array. The sub-array contains the indexes of the vertices that share
     * an edge with the vertex that owns the sub-array.
     * <p>
     * For example, if the graph has five vertices, then the returned array,
     * {@code edges}, then {@code edges.length} will be {@code 5}. If the vertex
     * at index {@code 2} within the graph has three edges, then {@code edges[2].length}
     * will be {@code 3}. If vertex {@code 4} is connected to vertices 
     * {@code 0}, {@code 1}, and {@code 3}, then {@code edges[4]} will be the
     * list {@code {0, 1, 3}}.
     * <p>
     * The array is returned by direct reference, i.e. not copied, and its
     * contents should not be modified.
     * 
     * @return an edge list representation of the graph
     */
    public int[][] getAdjacencyList() {
        if (adjacency == null) {
            int o = order;
            int[][] e = new int[o][];
            int row[] = new int[o];
            for (int r=0; r<o; r++) {
                int d = 0;
                for (int c=0; c<o; c++)
                    if (getEdge(r, c))
                        row[d++] = c;
                e[r] = Arrays.copyOf(row, d);
            }
            adjacency = e;
        }
        return adjacency;
    }
    
    /**
     * Returns the
     * <a href="https://en.wikipedia.org/wiki/Degree_(graph_theory)#Degree_sequence">
     * degree sequence</a> of the graph. The array is returned by direct
     * reference, i.e. not copied, and should not be modified.
     * 
     * @return the degree sequence
     */
    public int[] getDegreeSequence() {
        if (degrees == null) {
            int o = order;
            int[][] e = getAdjacencyList();
            int[] d = new int[o];
            for (int i=0; i<o; i++)
                d[i] = e[i].length;
            // This is a rubbish way to get decending order, but for the 
            // sorting methods for primative do not accept comparators and 
            // I'm too lazy to write a sorting algorithm just for this.
            Arrays.sort(d);
            for (int i=0, j=o-1; i<j; i++, j--) {
                int t = d[i];
                d[i] = d[j];
                d[j] = t;
            }
            degrees = d;
        }
        return degrees;
    }
    
    /**
     * Returns a jagged array representation of the disjoint components of this
     * graph.
     * <p>
     * If the returned array has length {@code n}, then this graph has {@code n}
     * disjoint components whose union is equal to this graph. If
     * {@code getComponents()[0].length == m}, then the first component of this
     * graph contains {@code m} vertices and their indices (in {@code this}
     * graph) are stored in {@code getComponents()[0]}.
     * <p>
     * The array is returned by direct reference, i.e. not copied, and its
     * contents should not be modified.
     *
     * @return a jagged array representation of the disjoint components of this
     * graph
     */
    public int[][] getComponents() {
        if (components == null) {
            int[][] edges = getAdjacencyList();
            // The total number of components
            int compCount = 0;
            // The array of components
            int[][] comps = new int[order][];
            // The current component
            int[] currComp = new int[order];
            // The vertex queue
            int[] queue = new int[order];
            int queueFront = 0;
            int queueBack = 0;
            // Keep track of which vertexes have been visted
            boolean[] visited = new boolean[order];
            // Keep track of the next vertex that has not been visted
            int visitPos = 0;
            // Continue until all verticies have been visited
            while (queueFront < order) {
                // The size of the current compoennt
                int currCompSize = 0;
                // Find the next unvisited verted
                while (visitPos < order && visited[visitPos])
                    visitPos++;
                // Mark it as visted
                visited[visitPos] = true;
                // Add it to the queue
                queue[queueBack++] = visitPos;
                // Until the queue is empty
                while (queueFront < queueBack) {
                    // Get the next vertex from the front of the queue
                    int v = queue[queueFront++];
                    // Add the vertex to the componenet
                    currComp[currCompSize++] = v;
                    // Get the array of vertices adjacent to this vertex
                    int[] edgesV = edges[v];
                    // Get the number of adjacent vertices
                    int len = edgesV.length;
                    // For each adjacent vertex
                    for (int i=0; i<len; i++) {
                        int w = edgesV[i];
                        // If the adjacent vertex has not been visted...
                        if (!visited[w]) {
                            // Enqueue the connected vertex
                            queue[queueBack++] = w;
                            // And mark it as visted
                            visited[w] = true;
                        }
                    }
                }
                // Store the completed component
                comps[compCount++] = Arrays.copyOf(currComp, currCompSize);
            }
            // Truncate the components arrays
            comps = Arrays.copyOf(comps, compCount);
            // Sort the components in ascending order by vertex count
            Arrays.sort(comps, Comparator.comparingInt(a -> a.length));
            // Store the components
            components = comps;
        }
        return components;
    }
    
    /**
     * Returns an array of disjoint subgraphs whose union is equal to this 
     * graph.
     * <p>
     * The array is returned by direct reference, i.e. not copied, and its
     * contents should not be modified.
     * 
     * @return an array of disjoint subgraphs
     */
    public Subgraph[] getComponentSubgraphs() {
        if (componentGraphs == null) {
            int[][] comps = getComponents();
            Subgraph[] subs = new Subgraph[comps.length];
            for (int i=0; i<subs.length; i++)
                subs[i] = makeSubgraphInternal(this, comps[i]);
            componentGraphs = subs;
        }
        return componentGraphs;
    }
    
    /**
     * Returns the number of disjoint components in this graph.
     * 
     * @return the number of disjoint components in this graph.
     */
    public int getNumComponents() {
        return getComponents().length;
    }
    
    /***************************************************************************
     * Lazy Getters (Experimental)
     **************************************************************************/
    
    /**
     * Returns an array containing every BFS-SLR tree on this graph (each
     * BFS-SLR tree is rooted at a different index).
     * <p>
     * <b>Experimental</b>
     * 
     * @return an array containing every BFS-SLR tree on this graph
     */
    public Tree[] getBfsSlrTrees() {
        if (bfsslrTrees == null) {
            Tree[] trees = new Tree[order];
            for (int i=0; i<order; i++) {
                Tree t = Tree.makeBfsSlrTree(this, i);
                t.getCanonicalNumber();
                trees[i] = t;
            }
            // Sort the trees by canonical number in ascending order
            Arrays.sort(trees, (Tree a, Tree b) -> {
                if (a.root.canonicalBits < b.root.canonicalBits) return -1;
                if (b.root.canonicalBits < a.root.canonicalBits) return 1;
                long[] canonA = a.root.canonicalNumber;
                long[] canonB = b.root.canonicalNumber;
                for (int i=canonA.length-1; i>=0; i--) {
                    if (canonA[i] < canonB[i]) return -1;
                    if (canonB[i] < canonA[i]) return 1;
                }
                return 0;
            });
            bfsslrTrees = trees;
        }
        return bfsslrTrees;
    }
    
    /**
     * Returns a number bit-packed into a {@code long} array which represents
     * much of the topology of the graph. Generated by sorting and concatenating
     * the canonical numbers of the BFS-SLR trees. Isomorphism invariant.
     * <p>
     * <b>Experimental</b>
     */
    public long[] getBfsSlrTreeNumber() {
        if (bfsslrTreeNumber == null) {
            // Get the BFS-SLR tree for each vertex
            Tree[] trees = getBfsSlrTrees();
            // Generate the canonical number for each tree and keep track of the
            // total number of bits used to represent all of the numbers
            int bitCount = 0;
            for (int i=0; i<trees.length; i++) {
                trees[i].getCanonicalNumber();
                bitCount += trees[i].getCanonicalBitLength();
            }
            // Create an array with enough room to hold this graph's BFS-SLR
            // number
            long[] number = new long[(bitCount+63)/64];
            // Keep track of the bit position within the number
            int bitPos = 0;
            // For each tree..
            for (int i=0; i < trees.length; i++) {
                // Get the tree's canonical number
                long[] cNumber = trees[i].getCanonicalNumber();
                int cBits = trees[i].getCanonicalBitLength();
                // Copy the tree number into the graph's number
                Tree.bitwiseCopy(cNumber, 0, number, bitPos, cBits);
                // Increment the bit index
                bitPos += cBits;
            }
            // Store the BFS-SLR number
            bfsslrTreeNumber = number;
        }
        return bfsslrTreeNumber;
    }
    
    
    /**
     * A possible semi-canonical mapping which can accelerate isomorphism tests in
     * some circumstances.
     * <p>
     * Given two graphs {@code g} and {@code h}, if 
     * {@code Arrays.equals(g.getBfsSlrTreeNumber(), h.getBfsSlrTreeNumber()}
     * then the mapping {@code m}, given by {@code m[h.getBfsSlrMap()[i]] = g.getBfsSlrMap()[i]}
     * for {@code 0 <= i < g.order()} may be an isomphic mapping from the 
     * vertex indicies in {@code h} to {@code g}.
     * <p>
     * <b>Experimental</b>
     */
    public int[] getBfsSlrMap() {
        if (bfsslrMap == null) {
            Tree[] trees = getBfsSlrTrees();
            int[] map = new int[order];
            for (int i=0; i<order; i++)
                map[i] = trees[i].root.vertex;
            bfsslrMap = map;
        }
        return bfsslrMap;
    }
    
    
    /***************************************************************************
     * Property Tests
     **************************************************************************/
    
    /**
     * Returns {@code true} if the graph has no edges.
     * 
     * @return {@code true} if the graph has no edges.
     */
    public boolean isEmpty() {
        return getSize() == 0;
    }
    
    /**
     * Returns {@code true} if the graph is a complete graph. A graph is
     * complete if every vertex is connected to every other vertex by an edge.
     * 
     * @return {@code true} if the graph is a complete graph
     */
    public boolean isComplete() {
        return getSize() == getMaximumSize();
    }
    
    /**
     * Returns {@code true} if the graph is regular. A graph is regular when
     * every vertex has the same degree.
     * 
     * @return {@code true} if the graph is regular
     */
    public boolean isRegular() {
        int[] d = getDegreeSequence();
        int v = d[0];
        for (int i=1; i<d.length; i++)
            if (d[i] != v)
                return false;
        return true;
    }
    
    /**
     * Returns {@code true} if the graph is connected. A graph is connected if
     * there is there is a path from every vertex to every other vertex.
     * 
     * @return {@code true} if the graph is connected
     */
    public boolean isConnected() {
        long s = getSize();
        if (s < order-1)
            return false;
        if (s >= maxSize-order+1)
            return true;
        return getComponents().length == 1;
    }
    
    /**
     * Returns {@code true} if the graph is a cycle graph.
     * 
     * @return {@code true} if the graph is a cycle graph
     */
    public boolean isCycleGraph() {
        return isConnected() && getSize() == order;
    }
    
    /**
     * Returns {@code true} if the graph is connected and contains no cycles.
     * 
     * @return {@code true} if the graph is connected and contains no cycles
     */
    public boolean isTree() {
        return isConnected() && getSize() == order-1;
    }
    
    /**
     * Returns {@code true} if each of the graph's disjoint components is a tree
     * (contains no cycles).
     * 
     * @return {@code true} if each of the graph's disjoint components is a tree
     */
    public boolean isForest() {
        if (isConnected()) {
            return getSize() == order-1;
        } else {
            Graph[] sub = getComponentSubgraphs();
            for (int i=0; i<sub.length; i++)
                if (!sub[i].isTree())
                    return false;
            return true;
        }
    }
    
    
    
    /***************************************************************************
     * Equality
     **************************************************************************/
    
    /**
     * Returns the hash code for this {@code Graph}.
     * 
     * @return the hash code for this {@code Graph}
     */
    @Override
    public int hashCode() {
        int hash = 1;
        for (long i=0; i<maxSize; i++)
            hash = 31 * hash + (getEdge(i)? 1231 : 1237);
        return hash;
    }
    
    /**
     * Returns {@code true} if the specified object is a {@code Graph} with the
     * same number of vertices as this graph and its adjacency matrix is
     * identical to the adjacency matrix of this graph. This method does not
     * check for isomorphic equivalence.
     * 
     * @param obj the reference object with which to compare
     * @return {@code true} if {@code obj} is a graph whose adjacency matrix is
     * identical to this graphs adjacency matrix
     */
    @Override
    public boolean equals(Object obj) {
        if (obj == null)
            return false;
        if (!(obj instanceof Graph))
            return false;
        Graph g = (Graph)obj;
        if (g.order != order)
            return false;
        for (long i=0; i<maxSize; i++)
            if (g.getEdge(i) != getEdge(i))
                return false;
        return true;
    }
    
    /**
     * Returns {@code true} if the this graph is equal to the specified graph
     * under the provided vertex mapping. 
     * <p>
     * In more precise terms, if for every pair of vertex indices {@code a} and 
     * {@code b} it holds that 
     * {@code (this.getEdge(a, b) == g.getEdge(map[a], map[b])}, then this
     * method will return {@code true}, otherwise it will return {@code false}.
     * This method also returns {@code false} if the order of the provided graph
     * is not equal to the order of this graph.
     * 
     * @param g the graph to test equality against
     * @param map the vertex map
     * @return {@code true} if the this graph is equal to the specified graph
     * under the provided vertex mapping
     */
    public boolean equals(Graph g, int[] map) {
        if (g.order != order)
            return false;
        long i=0;
        for (int r=1; r<order; r++) {
            int R = map[r];
            for (int c=0; c<r; c++) {
                if (getEdge(i++) != g.getEdge(R, map[c])) {
                    return false;
                }
            }
        }
        return true;
    }
    
    
    
    /***************************************************************************
     * Isomorphism
     **************************************************************************/
    
    /**
     * Returns {@code true} if this graph is isomorphic to the specified graph.
     * <p>
     * Equivalent to {@code getIsomorphicMap(g) != null}.
     * 
     * @param g the graph with which to test for isomorphism
     * @return {@code true} if this graph is isomorphic to the specified graph
     */
    public boolean isIsomorphic(Graph g) {
        return getIsomorphicMap(g) != null;
    }
    
    /**
     * Returns an isomorphic mapping using the Johnson Trotter permutation
     * algorithm, or {@code null} if no isomorphic mapping exists.
     * <p>
     * If an isomorphism exists between this graph and the specified graph, then
     * the returned map will contain an isomorphic mapping from the vertex 
     * indexes in this graph to the vertex indices in the specified map.
     * 
     * @param g the graph with which to find the isomorphic mapping
     * @return an isomorphic mapping, or {@code null}
     */
    public int[] getIsomorphicMap(Graph g) {
        
//        // Fast Fail: Order
//        if (order != g.order)
//            return null;
//        
//        // Fast Fail: Size
//        if (getSize() != g.getSize())
//            return null;
//        
//        // Fast Fail: Degree Sequence
//        if (!Arrays.equals(getDegreeSequence(), g.getDegreeSequence()))
//            return null;
        
        // Fast Fail: BFS-SLR Tree Number
        if (!Arrays.equals(getBfsSlrTreeNumber(), g.getBfsSlrTreeNumber()))
            return null;
        
        
        
        int[] hBfsSlrMap = getBfsSlrMap();
        int[] gBfsSlrMap = g.getBfsSlrMap();
        int[] map = new int[order];
        for (int i=0; i<order; i++)
            map[hBfsSlrMap[i]] = gBfsSlrMap[i];
        if (equals(g, map))
            return map;
        
        // TODO: Try permutation cycles
        
        // Brute Force: Iterative Johnson-Trotter Permutation Algorithm
        int ord = order;         
        int[] prm = new int[ord];
        int[] inv = new int[ord];
        int[] dir = new int[ord];
        int[] cnt = new int[ord];
        for (int i=0; i<ord; i++) {
            prm[i] = i;
            inv[i] = i;
            dir[i] = -1;
        }
        if (equals(g)) {
            return prm;
        }
        for (int idx = ord-1; idx >=0; ) {
            int i = inv[idx];
            int d = dir[idx];
            int q = i + d;
            int z = prm[q];
            prm[i] = z;
            prm[q] = idx;
            inv[z] = inv[idx];
            inv[idx] = q;
            cnt[idx]++;
            for (idx = ord-1; idx >= 0 && cnt[idx] == idx; idx--) {
                dir[idx] = -dir[idx];
                cnt[idx] = 0;
            }
            if (equals(g, prm)) {
                return prm;
            }
        }
        
        // Failed Exhaustive Search
        return null;
    }
    
    
    
    /***************************************************************************
     * Static Constructors
     **************************************************************************/
    
    /**
     * Constructs and returns a copy of the specified graph.
     * 
     * @param g the graph to copy
     * @return a copy of the specified graph
     * @throws NullPointerException if {@code g} is {@code null}
     */
    public static Graph makeCopy(Graph g) {
        Graph h = new BaseGraph(g.order);
        for(long i = 0; i < h.maxSize; i++)
            if (g.getEdge(i))
                h.setEdgeInternal(i, true);
        return h;
    }
    
    /**
     * Constructs and returns a new empty graph on the specified number of vertices.
     * 
     * @param order the number of vertices
     * @return new empty graph
     * @throws IllegalArgumentException if a graph with the specified number of
     * vertices could not be constructed
     */
    public static Graph makeEmptyGraph(int order) {
        return new BaseGraph(order);
    }
    
    /**
     * Constructs and returns a new graph with the specified number of vertices
     * whose adjacency matrix is set by interpreting the specified string as a
     * decimal integer and copying bits from the integer's binary
     * representation.
     * <p>
     * Equivalent to {@code makeFromString(order, str, 10, TraversalOrder.LRTB)}.
     * 
     * @param order the number of vertices
     * @param str string representation of a decimal integer
     * @return the newly constructed graph
     * @throws IllegalArgumentException if a graph with the specified number of
     * vertices could not be constructed
     * @throws NullPointerException if {@code str} is {@code null}
     * @throws NumberFormatException {@code str} is not a valid representation
     * of a decimal integer
     * @see #fromString(String) 
     * @see #makeFromString(int, String, int, TraversalOrder) 
     */
    public static Graph makeFromString(int order, String str) {
        Graph g = new BaseGraph(order);
        g.fromString(str);
        return g;
    }
    
    /**
     * Constructs and returns a new graph with the specified number of vertices
     * whose adjacency matrix is set by interpreting the specified string as an
     * integer with the specified radix and copying bits from the integer's
     * binary representation into the adjacency matrix using the traversal order
     * specified such that the first bit traversed in the matrix is equivalent
     * to the least significant bit in the integer.
     * If the integer contains more bits than the lower triangle of the
     * adjacency matrix, it will be truncated. If the integer contains few bits
     * than the lower triangle of the adjacency matrix, the remaining bits will
     * be zeroed (set to {@code false}).
     * <p>
     * Equivalent to
     * {@code makeFromBigInt(order, new BigInteger(str, radix), traversalOrder)}.
     * 
     * @param order the number of vertices
     * @param str string representation of a integer
     * @param radix the radix to be used in interpreting {@code str}
     * @throws NullPointerException if {@code str} or {@code traversalOrder} are
     * {@code null}
     * @param traversalOrder the order bits are be read from the adjacency
     * matrix
     * @return the newly constructed graph
     * @throws IllegalArgumentException if a graph with the specified number of
     * vertices could not be constructed
     * @throws NullPointerException if either {@code str} or
     * {@code traversalOrder} are {@code null}
     * @throws NumberFormatException {@code str} is not a valid representation
     * of an integer in the specified radix, or radix is outside the range
     * [{@code Character.MIN_RADIX}, {@code Character.MAX_RADIX}]
     * @see #fromString(String, int, TraversalOrder)
     * @see BigInteger#BigInteger(java.lang.String, int) 
     * @see #makeFromBigInt(int, BigInteger, TraversalOrder) 
     */
    public static Graph makeFromString(int order, String str, int radix, TraversalOrder traversalOrder) {
        Graph g = new BaseGraph(order);
        g.fromString(str, radix, traversalOrder);
        return g;
    }
    
    /**
     * Constructs and returns a new graph with the specified number of vertices
     * whose adjacency matrix is set by copying bits from the specified integer. 
     * If the integer contains more bits than the lower triangle of the
     * adjacency matrix, it will be truncated. If the integer contains few bits
     * than the lower triangle of the adjacency matrix, the remaining bits will
     * be zeroed (set to {@code false}).
     * <p>
     * Equivalent to makeFromBigInt(order, integer, TraversalOrder.LRTB)}.
     * 
     * 
     * @param order the number of vertices
     * @param bigint the integer whose bits will be copied
     * @return the newly constructed graph
     * @throws IllegalArgumentException if a graph with the specified number of
     * vertices could not be constructed
     * @throws NullPointerException if {@code integer} is {@code null}
     * @see #fromBigInt(BigInteger)
     * @see #makeFromBigInt(int, BigInteger, TraversalOrder) 
     */
    public static Graph makeFromBigInt(int order, BigInteger bigint) {
        Graph g = new BaseGraph(order);
        g.fromBigInt(bigint);
        return g;
    }
    
    /**
     * Constructs and returns a new graph with the specified number of vertices
     * whose adjacency matrix is set by traversing the lower triangle of the
     * matrix in the order specified and copying bits from the binary
     * representation of the specified integer such that the first bit traversed
     * in the matrix is equivalent to the least significant bit in the specified
     * integer.
     * If the integer contains more bits than the lower triangle of the
     * adjacency matrix, it will be truncated. If the integer contains few bits
     * than the lower triangle of the adjacency matrix, the remaining bits will
     * be zeroed (set to {@code false}).
     * 
     * @param order the number of vertices
     * @param bigint the integer whose bits will be copied
     * @param traversalOrder the order in which bits will be set in the
     * adjacency matrix
     * @return the newly constructed graph
     * @throws IllegalArgumentException if a graph with the specified number of
     * vertices could not be constructed
     * @throws NullPointerException if either {@code integer} or
     * {@code traversalOrder} are {@code null}
     * @see #fromBigInt(BigInteger, TraversalOrder) 
     */
    public static Graph makeFromBigInt(int order, BigInteger bigint, TraversalOrder traversalOrder) {
        Graph g = new BaseGraph(order);
        g.fromBigInt(bigint, traversalOrder);
        return g;
    }
    
    /**
     * Constructs and returns a new complete graph on the specified number of
     * vertices.
     *
     * @param order the number of vertices
     * @return a new complete graph
     * @throws IllegalArgumentException if a graph with the specified number of
     * vertices could not be constructed
     */
    public static Graph makeCompleteGraph(int order) {
        Graph g = new BaseGraph(order);
        g.complement();
        return g;
    }
    
    /**
     * Constructs and returns a new cycle graph on the specified number of
     * vertices.
     *
     * @param order the number of vertices
     * @return a new cycle graph
     * @throws IllegalArgumentException if a graph with the specified number of
     * vertices could not be constructed
     */
    public static Graph makeCycleGraph(int order) {
        Graph g = new BaseGraph(order);
        for (int i=0; i<order; i++)
            g.setEdgeInternal(i, (i+1)%order, true);
        return g;
    }
    
    /**
     * Constructs and returns a new star graph on the specified number of
     * vertices using the vertex with the specified index as the inner vertex of
     * the star.
     *
     * @param order the number of vertexes in the graph
     * @param index the index of the vertex to use as the inner vertex
     * @return a new star graph
     * @throws IllegalArgumentException if a graph with the specified number of
     * vertices could not be constructed
     * @throws IllegalArgumentException if {@code index} is not in range [0, {@code order})
     */
    public static Graph makeStarGraph(int order, int index) {
        Graph g = new BaseGraph(order);
        for (int i=0; i<order; i++)
            g.setEdgeInternal(i, index, true);
        return g;
    }
    
    /**
     * Constructs and returns a new graph that is the subgraph of the specified
     * graph using the specified vertex mapping. The returned graph will have
     * {@code map.length} vertices, and the {@code i}-th vertex of the returned
     * graph will correspond to the {@code map[i]}-th vertex of the specified
     * graph.
     * <p>
     * Note: Once a subgraph has been constructed it is disjoint from the
     * supergraph that was used to construct it. In other words, subsequent
     * changes to the supergraph <b>will not</b> be reflected in the subgraph,
     * and vice versa.
     *
     * @param graph graph containing the subgraph
     * @param map vertex mapping from indices in the subgraph to the supergraph
     * @return a new graph that is the subgraph of the specified graph using
     * the specified vertex mapping
     * @throws NullPointerException if {@code graph} or {@code map} is
     * {@code null}
     * @throws IllegalArgumentException if {@code map.length} is less than
     * {@code 1} or greater than {@code graph.order()}
     * @throws IllegalArgumentException if {@code map} contains a value that is
     * not in the range [0,{@code graph.order()}), or map contains a repeated
     * value
     */
    public static Subgraph makeSubgraph(Graph graph, int[] map) {
        int order =  graph.order;
        if (map.length < 1 || map.length > order)
            throw new IllegalArgumentException("map.length is not in range: map.length="+map.length+", range=[1,"+order+"]");
        boolean[] isValid = new boolean[order];
        for (int i=0; i<map.length; i++) {
            int index = map[i];
            if (index < 0 || index >= order)
                throw new IllegalArgumentException("map contains an index that is not in range: index="+index+", range=[0,"+order+")");
            if (!isValid[index])
                throw new IllegalArgumentException("map contains an duplicate index: index="+index);
            isValid[index] = true;
        }
        return makeSubgraphInternal(graph, map);
    }
    
    /**
     * Internal implementation of
     * {@link #makeSubgraph(com.jnhankins.graph.Graph, int[]) makeSubgraph}.
     * The implementation assumes the input is valid.
     * 
     * @param graph graph containing the subgraph
     * @param map vertex mapping from indices in the subgraph to the supergraph
     * @return a new graph that is the subgraph of the specified graph using
     * @param order the order of the new graph (use only the first {@code n}
     * values of {@code map} where {@code n=order})
     * the specified vertex mapping
     */
    private static Subgraph makeSubgraphInternal(Graph graph, int[] map) {
        return new Subgraph(graph, map, true);
    }
    
    
    
    /***************************************************************************
     * Enumerators
     **************************************************************************/
    
    /**
     * Returns an iterator that generates all labeled graphs with the specified
     * number of vertices.
     * 
     * @param order the number of vertices
     * @return an iterator that generates all labeled graphs with the specified
     * number of vertices
     * @see #increment()
     */
    public static Iterator<Graph> itLabeledGraphs(int order) {
        return new Iterator<Graph>() {
            final Graph g = makeEmptyGraph(order);
            boolean b = true;
            
            @Override
            public boolean hasNext() {
                return b;
            }

            @Override
            public Graph next() {
                Graph h = makeCopy(g);
                b = g.increment();
                return h;
            }
        };
    }
    
    /**
     * Returns a list of all labeled graphs with the specified number of
     * vertices.
     *
     * @param order the number of vertices
     * @return a list of all labeled graphs with the specified number of
     * vertices
     * @see #itLabeledGraphs(int) 
     * @see #increment() 
     */
    public static ArrayList<Graph> getLabledGraphs(int order) {
        ArrayList<Graph> list = new ArrayList();
        Iterator<Graph> it = itLabeledGraphs(order);
        while (it.hasNext())
            list.add(it.next());
        return list;
    }
    
    /**
     * Returns an iterator that generates all connected labeled graphs with the
     * specified number of vertices.
     * <p>
     * Calling the returned iterators {@code next()} method always returns the
     * same {@code Graph} object instance, however the graph is modified between
     * successive calls to {@code next()} by
     * {@link Graph#increment() incrementing} the graph until the next connected
     * graph is found.
     * 
     * @param order the number of vertices
     * @return an iterator that generates all connected labeled graphs with the
     * specified number of vertices
     * @see #isConnected()
     */
    public static Iterator<Graph> itConnectedGraphs(int order) {
        return new Iterator<Graph>() {
            final Graph g = makeStarGraph(order, 1);
            boolean b = true;
            
            @Override
            public boolean hasNext() {
                return b;
            }

            @Override
            public Graph next() {
                Graph h = makeCopy(g);
                do {
                    b = g.increment();
                } while (b && !g.isConnected());
                return h;
            }
        };
    }
    
    /**
     * Returns a list of all connected labeled graphs with the specified number
     * of vertices.
     *
     * @param order the number of vertices
     * @return a list of all connected labeled graphs with the specified number
     * of vertices
     * @see #itConnectedGraphs(int) 
     * @see #isConnected() 
     */
    public static ArrayList<Graph> getConnectedGraphs(int order) {
        ArrayList<Graph> list = new ArrayList();
        Iterator<Graph> it = itConnectedGraphs(order);
        while (it.hasNext())
            list.add(it.next());
        return list;
    }  
    
    
    
    /***************************************************************************
     * Miscellaneous Static Methods
     **************************************************************************/
    
    /**
     * Returns the n-th term in the sequence of triangular numbers. This is
     * sequence <a href="https://oeis.org/A000217">A000217 in OEIS</a>. The n-th
     * term in the sequence is given by the formula {@code n*(n+1)/1}. Beginning
     * with the 0th triangle number, the sequence is 0, 1, 3, 6, 10, 15, 21, 28,
     * 36, 45, 55, 66, 78, 91, 105, 120, 136, 153, 171, 190, 210, 231, 253, 276,
     * 300, 325, 351, 378, 406...
     *
     * @param n the index of the triangular number
     * @return the n-th triangular number
     */
    public static long triangular(long n) {
        return n*(n+1)/2;
    }
    
    /**
     * Returns the index of the specified nonnegative triangular number in
     * the sequence of triangular numbers, or {@code -1} if the specified number
     * is negative or not triangular.
     * 
     * @param n the triangular number
     * @return the position of the triangular number in the sequence, or {@code -1}
     */
    public static long triangularInv(long n) {
        long r = (long)Math.sqrt(8*n+1);
        return (r*r == n)? (r-1)/2: -1;
    }
    
    /**
     * Returns the index of the largest triangular number that is less than the
     * specified number.
     * 
     * @param n the number
     * @return the index of the largest triangular number that is less than the
     * specified number
     */
    public static long trinalgeInvFloor(long n) {
        return ((long)Math.sqrt(8*n+1)-1)/2;
    }
    
    /**
     * Returns the largest triangular number that is less than the specified
     * number.
     * 
     * @param n the number
     * @return the largest triangular number that is less than the specified
     * number
     */
    public static long triangularFloor(long n) {
        return triangular(trinalgeInvFloor(n));
    }
    
    /**
     * Returns the maximum number of edges a graph with the specified number of
     * vertices could have. In other words, returns the number of edges in a
     * complete graph of the specified order.
     *
     * @param order the number of vertices
     * @return the number of edges in a complete graph of the specified order
     */
    public static long getMaximumSize(long order) {
        return triangular(order-1);
    }
    
    /**
     * Returns the number of unlabeled graphs with the specified number of
     * vertices. This is given by the exponential equation
     * {@code 2^(v*(v-1)/2)}, where {@code v} is the number of vertices.
     * 
     *
     * @param order the order of the graph
     * @return the approximate number of possible edge configurations for a
     * graph with the specified number of vertices
     * @throws ArithmeticException if the number of unlabeled graphs with the
     * specified number of vertices is too large to be represented by a
     * {@code long}
     */
    public static long getNumGraphs(long order) {
        long s = getMaximumSize(order);
        if (s > 63)
            throw new ArithmeticException();
        return 1L << s;
    }
    
    /**
     * Returns the approximate number of unlabeled graphs with the specified
     * number of vertices.. This is given by the exponential equation
     * {@code 2^(v*(v-1)/2)}, where {@code v} is the number of vertices.
     *
     * @param order the order of the graph
     * @return the approximate number of possible edge configurations for a
     * graph with the specified number of vertices
     */
    public static double getNumGraphsAprox(long order) {
        return Math.pow(2, getMaximumSize(order));
    }
    
    /**
     * Returns the number of bits that are set in the specified 64 bit integer.
     * In other words, this method counts the number of {@code 1}s in the binary
     * representation of the specified number.
     * <p>
     * For example, {@code 151} can be written in binary as {@code 1001011}. So,
     * if {@code 151} were supplied as the argument, this method would return
     * {@code 5}.
     * 
     * @param i the number whose set bits will be counted
     * @return the number of bits set in the specified {@code long}
     */
    public static long countSetBits(long i) {
        i = i - ((i >>> 1) & 0x5555555555555555L);
        i = (i & 0x3333333333333333L) + ((i >>> 2) & 0x3333333333333333L);
        return (((i + (i >>> 4)) & 0xF0F0F0F0F0F0F0FL) * 0x101010101010101L) >>> 56;
    }
    
    /**
     * Reverses the order of the bits in the specified 64 bit integer.
     * 
     * @param x the original number
     * @return the bit order reversed number
     */
    public static long reverseBits(long x) {
        x = (((x & 0xAAAAAAAAAAAAAAAAL) >>> 1) | ((x & 0x5555555555555555L) << 1));
        x = (((x & 0xCCCCCCCCCCCCCCCCL) >>> 2) | ((x & 0x3333333333333333L) << 2));
        x = (((x & 0xF0F0F0F0F0F0F0F0L) >>> 4) | ((x & 0x0F0F0F0F0F0F0F0FL) << 4));
        x = (((x & 0xFF00FF00FF00FF00L) >>> 8) | ((x & 0x00FF00FF00FF00FFL) << 8));
        x = (((x & 0xFFFF0000FFFF0000L) >>> 16) | ((x & 0x0000FFFF0000FFFFL) << 16));
        return ((x >>> 32) | (x << 32));
    }
    
    /**
     * Returns a randomly generated permutation of integers {@code 0} through
     * {@code length-1} inclusive.
     * 
     * @param length the length of the permutation
     * @return a randomly generated permutation
     */
    public static int[] randomPermutation(int length) {
        int[] permutation = new int[length];
        for (int i=1; i<length; i++)
            permutation[i] = i;
        randomPermutation(permutation);
        return permutation;
    }
    
    /**
     * Randomly permutes the values in the specified array.
     * 
     * @param permutation the array to permute
     */
    public static void randomPermutation(int[] permutation) {
        Random rand = new Random();
        int len = permutation.length;
        for (int i=0; i<len; i++) {
            int j = rand.nextInt(len);
            int swap = permutation[i];
            permutation[i] = permutation[j];
            permutation[j] = swap;
        }
    }
    
    /**
     * Returns {@code true} if the specified value is a positive power of two.
     * 
     * @param x the value to test
     * @return {@code true} if the specified value is a positive power of two
     */
    public static boolean isPowerOfTwo(int x) {
        return ((x > 0) && ((x & (~x + 1)) == x));
    }
    
    /**
     * Prints the contents of the specified array as a little-endian binary 
     * integer to the standard output stream.
     * <p>
     * Equivalent to {@code System.out.println(toBinaryString(array))}.
     * 
     * 
     * @param array the array to print
     */
    public static void printBinaryString(long[] array) {
        System.out.println(toBinaryString(array));
    }
    
    /**
     * Interprets the specified array a little-endian integer and converts the
     * integer into a binary string.
     * 
     * @param array the array to convert
     * @return a binary string representation of the array
     */
    public static String toBinaryString(long[] array) {
        StringBuilder build = new StringBuilder();
        int i = array.length-1;
        while (array[i] == 0) i--;
        build.append(Long.toBinaryString(array[i--]));
        while (i >= 0)
            build.append(String.format("%64s",Long.toBinaryString(array[i--])).replaceAll(" ", "0"));
        return build.toString();
    }
    
    /***************************************************************************
     * Implementations
     **************************************************************************/
    
    /**
     * An basic implementation of {@link Graph} which stores the adjacency 
     * matrix in a bit-packed {@code long} array.
     * <p>
     * Though bit-packing reduces the performance of random access to the matrix
     * when compared to a {@code boolean} array, it has a two advantages: 1)
     * Bit-packing uses one 64 as much memory as a boolean array. 2) Some
     * operations such as finding the graph's complement and testing for
     * equality can be performed more quickly using bitwise operations.
     * <p>
     * In principal, given enough memory this implementation can support graphs
     * having up to 524288 vertices.
     * 
     * @author Jeremiah N. Hankins
     */
    public static class BaseGraph extends Graph {
        public static final int MAX_ORDER = 524288;

        final long highMask;
        final long[] matrix;
        
        /**
         * Constructs a new {@code BaseGraph} with the specified number of
         * vertices.
         * 
         * @param order the number of vertices
         * @throws IllegalArgumentException if {@code order} is less than 1 or
         * greater than 524288
         */
        public BaseGraph(int order) {
            super(order);
            if (order < 1 || order > 524288)
                throw new IllegalArgumentException("order is not in range: order="+order+", range=[1,"+MAX_ORDER+"]");
            highMask = ~(-1L << (maxSize & 0x3F));
            matrix = new long[(int)((maxSize+63L)/64L)];
        }

        @Override
        public boolean getEdgeInternal(long edgeIndex) {
            return ((matrix[(int)(edgeIndex>>>6)] & (1L << edgeIndex))) != 0;
        }

        @Override
        public void setEdgeInternal(long edgeIndex, boolean value) {
            if (value)
                matrix[(int)(edgeIndex>>>6)] |= (1L << edgeIndex);
            else
                matrix[(int)(edgeIndex>>>6)] &= ~(1L << edgeIndex);
        }

        @Override
        public long getSize() {
            if (size == null) {
                if (order >= 128 && adjacency != null)
                    return super.getSize();
                long[] m = matrix;
                long total = 0;
                for (int i=0; i<m.length; i++)
                    total += countSetBits(m[i]);
                size = total;
            }
            return size;
        }

        @Override
        public void randomize() {
            if (matrix.length > 0) {
                Random random = new Random();
                for (int i=0; i<matrix.length; i++)
                    matrix[i] = random.nextLong();
                matrix[matrix.length-1] &= highMask;
                modified();
            }
        }

        @Override
        public void complement() {
            if (matrix.length > 0) {
                for (int i=0; i<matrix.length; i++)
                    matrix[i] = ~matrix[i];
                matrix[matrix.length-1] &= highMask;
                modified();
            }
        }

        @Override
        public boolean increment() {
            if (order == 1)
                return false;
            modified();
            long[] m = matrix;
            int n = m.length-1;
            for (int i=0; i<n; i++)
                if (++m[i] != 0)
                    return true;
            return (m[n] = ((m[n] + 1) & highMask)) != 0;
        }
        
        @Override
        public boolean increment(int x) {
            if (order == 1)
                return false;
            modified();
            long[] m = matrix;
            int len = m.length;
            if (len == 1) { 
                // Case 1: Array length is 1
                long q = m[0] + x;
                m[0] = q & highMask;
                return q <= highMask;
            } else {       
                // Case 2: Array length is > 1
                // Perform the first addition sepeatly
                long p = m[0];
                long q = p + x;
                m[0] = q;
                if (p >= 0 || q < 0)
                    return true;
                // Perform the middle additions
                int n = len-1;
                for (int i=1; i<n; i++) 
                    if (++m[i] != 0)
                        return true;
                // Perform the last addition
                return (m[n] = ((m[n] + 1) & highMask)) != 0;
            }
        }

        public boolean equals(BaseGraph g) {
            if (g == null)
                return false;
            if (g.order != order)
                return false;
            for (int i=0; i<matrix.length; i++)
                if (g.matrix[i] != matrix[i])
                    return false;
            return true;
        }
    }
    
    /**
     * A subgraph of a supergraph. A subgraph is derived from a super graph
     * using map from the vertex indices in the subgraph to the vertex indices
     * in the supergraph. 
     * <p>
     * Note: Once a subgraph has been constructed it is disjoint from the
     * supergraph that was used to construct it. In other words, subsequent
     * changes to the supergraph <b>will not</b> be reflected in the subgraph,
     * and vice versa.
     * 
     * @see #makeSubgraph(Graph, int[]) 
     * @author Jeremiah N. Hankins
     */
    public static class Subgraph extends BaseGraph {
        final Graph supergraph;
        final int[] map;

        /**
         * Constructs a new {@code Subgraph} of the specified graph using the
         * specified vertex mapping. The returned graph will have
         * {@code map.length} vertices, and the {@code i}-th vertex of the
         * returned graph will correspond to the {@code map[i]}-th vertex of the
         * specified graph.
         * <p>
         * Note: Once a subgraph has been constructed it is disjoint from the
         * supergraph that was used to construct it. In other words, subsequent
         * changes to the supergraph <b>will not</b> be reflected in the
         * subgraph, and vice versa.
         *
         * @param graph graph containing the subgraph
         * @param map vertex mapping from indices in the subgraph to the
         * supergraph
         * @throws NullPointerException if {@code graph} or {@code map} is
         * {@code null}
         * @throws IllegalArgumentException if {@code map.length} is less than
         * {@code 1} or greater than {@code graph.order()}
         * @throws IllegalArgumentException if {@code map} contains a value that
         * is not in the range [0,{@code graph.order()}), or map contains a
         * repeated value
         */
        public Subgraph(Graph graph, int[] map) {
            super(map.length);
            
            this.supergraph = graph;
            this.map = map;
            
            int max =  graph.order;
            if (map.length < 1 || map.length > max)
                throw new IllegalArgumentException("map.length is not in range: map.length="+map.length+", range=[1,"+max+"]");
            boolean[] isValid = new boolean[max];
            for (int i=0; i<map.length; i++) {
                int index = map[i];
                if (index < 0 || index >= max)
                    throw new IllegalArgumentException("map contains an index that is not in range: index="+index+", range=[0,"+max+")");
                if (!isValid[index])
                    throw new IllegalArgumentException("map contains an duplicate index: index="+index);
                isValid[index] = true;
            }
            
            long index = 0;
            for (int r=1; r<order; r++) {
                int R = map[r];
                for (int c=0; c<r; c++) {
                    if (supergraph.getEdge(R, map[c]))
                        setEdge(index, true);
                    index++;
                }
            }
        }
        
        /**
         * Constructor for {@code Subgraph} intended for internal use only.
         * Unlike the public constructor, this constructor does not check the
         * validity of the specified map. The boolean argument for this
         * constructor is completely ignored; its only purpose is to
         * differentiate this constructor from the public constructor via
         * overloading.
         * 
         * @param graph the graph containing the subgraph
         * @param map vertex mapping from indices in the subgraph to the
         * supergraph
         * @param ignored ignored
         */
        protected Subgraph(Graph graph, int[] map, boolean ignored) {
            super(map.length);
            
            this.supergraph = graph;
            this.map = map;

            long index = 0;
            for (int r=1; r<order; r++) {
                int R = map[r];
                for (int c=0; c<r; c++) {
                    if (graph.getEdge(R, map[c]))
                        setEdge(index, true);
                    index++;
                }
            }
        }

        /**
         * Returns the supergraph that was used to construct this graph.
         * 
         * @return the supergraph
         */
        public Graph getSupergraph() {
            return supergraph;
        }

        /**
         * Returns the map from vertex indices in this graph to the vertex
         * indices in the supergraph that was used to construct this subgraph.
         * 
         * @return the vertex mapping from this graph to its super graph
         */
        public int[] getSupergraphMap() {
            return map;
        }
    }
}
